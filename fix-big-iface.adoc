= Big interfaces

[%step]
--
> The bigger the interface, the weaker the abstraction.
>
> -- Rob Pike, https://www.youtube.com/watch?v=PAAkCSZUG1c&t=5m17s&themeRefresh=1[Gopherfest 2015]
--

[.notes]
--
Once we're defining interfaces,
one risk to be aware of is overly large interfaces.

Big interfaces indicate a tight coupling
between the producer of the abstraction and the consumer.
Or as Rob Pike put it, (*step*)
the bigger the interface, the weaker the abstraction.

Aim to make interfaces smaller.
Let me cover a couple tips to help with that.
--

[.columns]
== Follow the request path

[.column%step]
--
[source.medium,go]
----
type RedisStore struct{ /* ... */ }

func NewRedisStore(addr string) *RedisStore {
  /* ... */
}

func (*RedisStore) Get(string) (string, error) {
  /* ... */
}

func (*RedisStore) Set(k, v string) error {
  /* ... */
}

func (*RedisStore) Close() {
  /* ... */
}
----
--

[.column%step]
--
[source,go]
----
type Store interface {
  Get(string) (string, error)
  Set(k, v string) error
}
----

No `Close()`

[source%step,go]
----
s := NewRedisStore(addr)
defer s.Close()
consume(s)
// Given,
//   func consume(Store)
----
--

[.notes]
--
When deciding what goes on the interface,
don't just list all the methods of the object on the interface.

Think about the request path:
methods of the object that consumers will want to call --
probably many times.

For example, (*step*) suppose you have a Redis-based key-value store.
You have Get and Set, and maybe a Close method to clean up the connection.

The interface for the key value store should include (*step*):
Get, Set, but not Close.

Close is not part of the request path for a regular consumer.
They'll call Get and Set, but not Close.
Plus, if you think about it, not every store will have a Close method.
An in-memory data store won't have a meaningful close method.

So leave Close out of the interface.
It's accessible only if you have the actual `RedisStore` object,
which you do (*step*) outside the request path -- when you instantiated it.
--

[%auto-animate]
== Compose with functions

[source%linenums,go,data-id=SetMany]
----
func (s *RedisStore) SetMany(ks, vs []string) error {
  for i, k := range ks {
    err := s.Set(k, vs[i])
    if err != nil {
      return nil, err
    }
  }
  return nil
}
----

[.notes]
--
This brings up the question of convenient functionality
that you added to your abstraction.

Suppose the Redis Store also supported a SetMany method.
We could add this to the Store interface -- it's on the hot path --
but also note that the implementation is entirely composed
from the API we already expose from the Store interface.

We could just turn it into a function...
--

[%auto-animate]
== Compose with functions

[source%linenums,go,data-id=SetMany]
----
func SetMany(s Store, ks, vs []string) error {
  for i, k := range ks {
    err := s.Set(k, vs[i])
    if err != nil {
      return nil, err
    }
  }
  return nil
}
----

[.notes]
--
As an added benefit, this works with any Store,
not just RedisStore.

But of course, this isn't completely realistic;
redis probably has more optimal way of setting many items.

I'd like for RedisStore to use that instead.

I can do that with a tool we discussed before: upcasting.
--

[%auto-animate.columns.wrap]
== Compose with functions

[.column.is-full]
--
[source%linenums,go,data-id=SetMany]
----
func SetMany(s Store, ks, vs []string) error {
  if sm, ok := s.(SetManyStore); ok {
    return sm.SetMany(ks, vs)
  }
  for i, k := range ks {
    err := s.Set(k, vs[i])
    if err != nil {
      return nil, err
    }
  }
  return nil
}
----
--

[.column.is-half]
--
[source%linenums,go,data-id=SetManyStore]
----
type SetManyStore interface {
  Store
  SetMany(ks, vs []string) error
}
----
--

[.column.is-half%step]
--
[source%linenums,go,data-id=RedisStoreSetMany]
----
func (*RedisStore) SetMany(
  ks, vs []string,
) error { /* ... */ }
----
--

[.notes]
--
I define a new interface with the SetMany method,
and have the SetMany function check
if this method exists on the Store.

If it does, we can use the more optimized version (*step*)
implemented by the RedisStore.

Otherwise, we'll run the standard looping behavior
for all other stores.

This is pretty useful,
but it's not the only way to get this extension point.
In fact, in terms of ergonomics, it might not be cleanest experience
to have to use this top level function with your Store.
It's a bit hard on discoverability;
your IDE won't just auto-complete it when you write `store.`.

We can use the same technique, but with a wrapper struct instead...
--


[%auto-animate.columns.wrap]
== Build a strong core

[.column.is-full]
--
[source%linenums,go,data-id=SetMany]
----
type DataStore struct{ s Store }

func (d *DataStore) SetMany(ks, vs []string) error {
  s := d.s
  if sm, ok := s.(SetManyStore); ok {
    return sm.SetMany(ks, vs)
  }
  for i, k := range ks {
    /* ... */
  }
  return nil
}
----
--

[.column.is-half]
--
[source%linenums,go,data-id=SetManyStore]
----
type SetManyStore interface {
  Store
  SetMany(ks, vs []string) error
}
----
--

[.column.is-half]
--
[source%linenums.medium,go]
----
func (*DataStore) Get(k string) (string, error)
func (*DataStore) Set(k, v string) error
----
--

[.notes]
--
Here, I declare a new DataStore type that wraps a regular Store.

It implements Get and Set like a regular store,
but it also implements SetMany using the same logic as before:
if the wrapped store provides SetMany, use that,
otherwise loop.

So you get the best of all worlds:

* A small powerful interface
* Upgrade the interface per implementation as needed
* Operate on a rich object with convenient methods
--
