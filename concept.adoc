[.medium]
= What makes a package future-proof?

[quote]
The ability to evolve in functionality
without disrupting the code base

[.notes]
--
What do I mean when I say future-proof package?

For this talk, I'm making up this definition.

A package is future-proof if it has the ability to
evolve in functionality
without disrupting rest of code base.
--

== Disruption

[quote]
Being forced to modify code +
as a result of an unrelated change

[.notes]
--
Disruption here is being forced to
modify otherwise unrelated code
that previously worked
as a result of a change you made
elsewhere in the codebase.

Disruptions are bad.

* They reduce your velocity;
  you have to make a bunch of meaningless mechanical changes.
* They reduce your team's velocity;
  they increase the size of your PRs, increasing what has to be reviewed,
  as well as increasing the chances of a conflict.
* They increase risk of a breakage in production
  because something got missed.
--

== What causes disruption?

[%step]
[.step.fade-out]#Changes to packages with# +
a design that *leaks complexity*

[.notes]
--
Why does this happen?
What prevents us from evolving packages without disruptions?

This is my main thesis of my talk today:
(*next*)
code disruptions are caused by changes to packages
with a design that leaks complexity.

I'm using the term package here to refer to
an independent, modular, composible unit of code.
Or at least one intended to have those properties.

(*next*)
A design that leaks complexity.

Let me expand that.
--

== On complexity

// TODO: Diagram of hidden vs leaking complexity visualization

* Complexity is inevitable
* Good design hides complexity
* Complexity leaks causes fragility
* Fragility causes disruption

[.notes]
--
The existence of complexity is unavoidable.
Non-trivial systems deal with it at _some_ layer
so it has to exist somewhere.

The purpose of good design is to hide this complexity.

When it fails to do so, you get a fragile system,
and that fragility causes the disruptions we're talking about.
--
