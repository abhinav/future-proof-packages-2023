= Global state

[.notes]
--
Let's talk about global state.

Yeah, we all already know that global variables should be avoided.
That's not what I want to talk about.
I want to talk about...

// TODO: is this better?
// But there's more nuance to that.
// It's partly a matter of scope and perspective.
//
// Let's start with a position of most global variables are bad
// and talk about some of the exceptions.
//
// * Global variables that are computed once at startup
//   and never modified again, only read -- good!
// * Global variables that are written to at startup,
//   for example some kind of global registry -- probably fine!
// * Global variables that track ongoing metrics for incoming requests --
//   not great but there are bigger fish to fry!
// * Global variables used to communicate between functions,
//   as in set this variable and then call this function --
//   obviously absolutely not! That's illegal.
//
// The point I'm getting at is that the absolute position of
// all global variables are bad --
// that the mere act of reading from or writing to a global variable is bad --
// is wrong.
--

== Implicit process globals

[.notes]
--
Implicit process globals.

These refers to environment variables, stdout, stdin, etc.
These come under global state.

// TODO examples
For example, a little opt-in in your library or application
where if ENV_FOO is set, then you'll use the old behavior vs new.

There's nothing wrong with using environment variables
for flags and customizations like this.
I'm claiming that using that anywhere outside `main` is a leak.

// TODO: example code
The knowledge of the process' environment should remain in main.
Extract everything you need to extract from the environment
as early as possible in main, pull that into a data structure,
and plumb information down as needed.

A pattern I like to use here a lot is (TODO show `mainCmd` pattern).
This adds these two integration points for me to test:

* Inject a fake Getenv to test the parsing of environment into the struct
* In business logic, test just against the struct with no concern for
  environment

You probably already do this with `os.Args`:
parse in main and pass the parsed command line arguments around.
A random business logic component will not typically access `os.Args` directly.
Just carry that over to Getenv, Setenv, Stdin, Stdout, Signal, and friends.
--

== !

[quote]
--
Don't access or manipulate OS state outside the `main` package.
--

[.notes]
--
In short..
--

== Global registries

// TODO: side-note CSS

[.notes]
--
A quick note on global registries.
It's not uncommon for libraries to provide
a global registry of [thing] -- handlers, types, whatever.

If you do this,
just be sure to provide your callers a means of "going back"
to the point before they registered their thing.
--
