:concept-area-depth: ðŸ“¦ Surface area and depth

[.columns]
= Surface area

[.column.is-one-third]
--
--

[.column.text-left]
--
[pikchr,height=300px]
....
box "package" fit ht 0.5in
line thick color 0xEE9B00 "surface area" above from 0.05in above last.nw right until even with last.e
....
--

[.notes]
--
Surface area refers to the things exported from a package.
The part of a package that other packages can "touch".

Each exported function, type, and method -- each entry point --
adds to the surface area of the package.

Surface area does not necessarily correspond to how much functionality
the package offers.

That's a job for...
--

[.columns]
== {concept-area-depth}

[.column.is-one-third]
--
--

[.column.text-left]
--
[pikchr,height=300px]
....
box "package" fit ht 0.5in
line thick color 0xEE9B00 "surface area" above from 0.05in above last.nw right until even with last.e

line thick color 0x0A9396 " depth" ljust from 0.05in east of last box.ne down until even with last box.se
....
--

[.notes]
--
Building on the idea of packages as boxes with a surface area,
depth refers to how much work is done by exported components in the package.

In combination, these represent the functionality offered by the package.
--

== {concept-area-depth}

[pikchr, width=50%]
....
define areaAndDepth {
  line color 0xEE9B00 from $1.nw to $1.ne
  line color 0x0A9396 from $1.ne to $1.se
}

box "strings" fit width 2in
areaAndDepth(last box)

box "archive/tar" fit ht 1in with nw at 0.1in south of last box.sw
areaAndDepth(last box)
....

[.notes]
--
A package with lots of small helper functions has a wide surface area
and is shallow in functionality.

On the other hand, a package with only a handful of exported functions
hiding a bunch of complex work
has a narrow surface area and is deep in functionality.

One isn't objectively better than the other.
In real applications, there's a good balance to be had.

However...
--

[.columns.wrap]
== {concept-area-depth}

[.column.is-half]
--
Wide and shallow packages

* frequent entry and exit
* zigzagging
--

[.column.is-half]
--
Narrow and deep packages

* few entry points
* hide complexity
--

[.column.is-full%step]
--
Business packages should be narrow and deep
--

[.notes]
--
Just by virtue of their design,
wide and shallow packages encourage frequent entry and exit -- zigzagging.
While narrow and deep packages don't.

Therefore, (*step*) business packages should aim to
be narrow in surface area and deep in functionality.
--

[.columns]
== Shallow business packages

[.column]
--
Top-level functions with:

* RPC and IO
* Global state
* Many arguments
* Interrelated

[%step]
Might be in a 'util'
--

[.column]
--
[%step]
[pikchr]
....
Shallow: [
box "userutil" mono ht 0.3in wid 2in

// func{Above,Below}(distance from w, name)
define funcBelow {
  dot at $1 east of 1st box.w
  line thin from last dot down 1st box.ht
  text $2 mono below at last line.s
}
define funcAbove {
  dot at $1 east of 1st box.w
  line thin from last dot up 1st box.ht
  text $2 mono above at last line.n
}

funcBelow(0.3in, "GetUserList")
funcAbove(0.5in, "FilterUsers")
funcBelow(1.7in, "UserIsAdmin")
]

Deep: [
linewid = 0.3in
right
text "ListAdmins" mono
arrow
box "UserService" mono fit ht 0.75in
arrow
text "[]*User" mono
] with .n at 1in south of Shallow.s

text "Wide and shallow" big bold at 0.3in w of Shallow.nw
text "Deep and narrow" big bold at (last.x, Deep.n.y+0.1in)
....
--

[.notes]
--
There are other indicators,
but your business package is probably wide and shallow if it:

* has a bunch of functions that do complex business logic;
  making RPCs, writing to disk
* they rely on global state or have a *bunch* of arguments
* and they're mostly interrelated:
  information produced by one function is eventually passed into another

(*step*) They might all sit in a file or package called something util.


For example (*step*), if I have a package that exports those functions --
GetUserList, FilterUsers, UserIsAdmin --
I will flow in and out of that package.
It doesn't have a conceptual responsibility.

On the other hand,
if I find the purpose -- what is all this used for --
and build a named abstraction around it, I get a narrower, deeper abstraction.
--
