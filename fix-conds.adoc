:fix-conds: ðŸ”­ Large scoped conditions

= {fix-conds}

*Remove* special cases based on conditions +
that *don't change* in the *current context*

[%step]
[pikchr, height=400px]
....
X: [
A: arrow <-> right 2in

dot at (A.wid * 0.25, 0)

line from (A.wid * 0.5, 0.1in) down 0.2in
text "Current" with .s at last.n

dot at (A.wid * 0.75, 0)
arrow dashed rad 0.1in down 0.2in then left until even with 1st dot then up to 1st dot
line invis "if true" mono below from 0.2in south of 1st dot right until even with last dot
]


Y: [
A: arrow <-> right 2in

dot at (A.wid * 0.25, 0)

line from (A.wid * 0.75, 0.1in) down 0.2in
text "Current" with .s at last.n

dot at (A.wid * 0.5, 0)
arrow dashed rad 0.1in down 0.2in then left until even with 1st dot then up to 1st dot
line invis "if true" mono below from 0.2in south of 1st dot right until even with last dot
] with n at 1in south of last

arrow color gray from 0.3in south of X.s to Y.n
....

[.notes]
--
One great place to find the abstraction is by trying to eliminate
large scoped conditions.

What I mean by that is special cases -- if statements and the like --
based on variables that have a larger scope than the current context.

It makes sense that (*step*) if your condition is based on something
that doesn't change in the current scope, it should be evaluated earlier
and you should have an object that doesn't care about the condition.

This might be better demonstrated with an example...
--

[%auto-animate.columns.wrap]
== {fix-conds}

[.column.is-one-third]
--
[source%linenums,go,data-id=left]
----
type SiteGen struct {
  /* ... */
  LinkStyle LinkStyle
}
----
--

[.column.is-two-thirds%step]
--
[source%linenums,go,data-id=right]
----
func (g *SiteGen) RelativeURL(dst *Page) string {
  /* ... */
  switch g.LinkStyle {
  case LinkStyleDir:
    return u + "/"
  case LinkStylePlain:
    return strings.TrimSuffix(u, "/")
  case LinkStyleHTML:
    return u + ".html"
  }
}
----
--

[.column.is-one-third]
--
[source,go]
----
type LinkStyle int

const (
  LinkStyleDir   LinkStyle = iota
  LinkStylePlain
  LinkStyleHTML
)
----
--

[.notes]
--
Think back to the static website rendering example.
We declared an enum and placed it inside a struct field --
because it has scope larger than all the methods of SiteGen.

If we leave it at that, (*step*) we probably have logic that looks
something like this.
An if-else or a switch statement rendering the link based on the style.

This right here is a good place to find an abstraction.
In fact, if you recall from that part of the presentation,
we did find one...
--

[%auto-animate.columns.wrap]
== {fix-conds}

[.column.is-one-third]
--
[source%linenums,go,data-id=left]
----
type SiteGen struct {
  /* ... */
  LinkStyler LinkStyler
}
----
--

[.column.is-two-thirds]
--
[source,go]
----
func (g *SiteGen) RelativeURL(dst *Page) string {
  /* ... */
  return g.LinkStyle.StyleLink(u)
}
----
--

[.column.is-one-third]
--
[source,go]
----
type LinkStyler interface {
  StyleLink(string) string
}

type (
  DirLinkStyler   /* ... */
  PlainLinkStyler /* ... */
  HTMLLinkStyler  /* ... */
)
----
--

[.column.is-two-thirds]
--
[source%linenums,go,data-id=right]
----
func (DirLinkStyler) StyleLink(u string) string {
    return u + "/"
}

func (PlainLinkStyler) StyleLink(u string) string {
    return strings.TrimSuffix(u, "/")
}

func (HTMLLinkStyler) StyleLink(u string) string {
    return u + ".html"
}
----
--

[.notes]
--
The LinkStyler.
This is slightly different from what I showed before,
but it follows the same idea.

The condition of which style is being used is no longer a concern
for the site generator.
It's evaluated in a scope larger than SiteGen,
and SiteGen just gets an object that it can use unconditionally
to style links.

This same concept of removing conditions with larger scope
applies in other contexts.
For example, instead of `if production { .. }` in 5 different places,
decide whether you're in production well in advance,
and pass in an object that behaves as one should in production or development
as the case may be.
--
