= Finding and fixing problems

[.notes]
--
Finding and fixing problems.

First, just to recap,
I said earlier that packages aren't future-proof
if changing them causes disruptions,
and I claimed that that's a symptom of a design that leaks complexity.

So how do we go about fixing these leaks?
I will talk about this at two levels:

* First, low-level closer to the code.
  Patterns you should keep an eye out for
  that *probably* leak complexity.
* After that, I'll zoom out and talk about design at a higher level.

As I get into the first section,
please be aware that I'll be making generalizations.
The way to interpret this is
"code that looks like this tends to leak complexity".

// TODO: probably don't need to hedge here.
// TODO: explain how each thing might leak complexity

Okay, let's get into it.

// TODO:
//
// * Closure or callback heavy APIs
// ** You can implement a class a closure doesn't mean you should.
// ** Isolate concepts, give them names, add interfaces (middleware example)
// ** Related: If there's an interface, prefer an object over closure. More maintainable.
// *** Closure want to be objects when they grow up
// * Unstoppable goroutines
// ** Add a means of stopping them -- context or otherwise
// ** Never spawn in `init()`
//
// Maybe:
//
// * Naming: names and scopes
// ** Inconsistency in naming
// ** Stuttering
// ** Document public API of internal types with exported names
// ** Consistency above all else
// * Errors: structured and sentinel
// * Bidirectional channels at boundaries / channels are rare
--

// TODO: many functions, adapt the long-funcs strategy

= Over-reliance on primitives

[.notes]
--
Something that makes it easy to leak complexity is
an over-reliance on primitive types in your core logic.

strings, bools, and ints are available everywhere -- they're so easy to use --
so I use them everywhere because defining a type "adds complexity" to my code.
As a result of that, I end up leaking that complexity outside.

I think this is better demonstrated with an example.
--

include::fix-string.adoc[]
include::fix-map.adoc[]
include::fix-serialized-types.adoc[]
include::fix-bool.adoc[]
include::fix-callback.adoc[]
// TODO: maybe: closures vs objects
include::fix-premature-iface.adoc[]
include::fix-big-iface.adoc[]
include::fix-global.adoc[]

= Zooming out

[.notes]
--
So I've been talking about very specific code samples.
As promised, I'm going to zoom out now.
Now I want to talk about an application holistically.
--

include::concept-flow.adoc[]
include::concept-area-depth.adoc[]

== !

[.notes]
--
Unfortunately, I don't have a list of rules that we can follow
to always get the right abstraction.
But I have some tools that'll help you find it.

// TODO
//
// * single point of entry for modules that do one thing
// * look for conditionals
// * currying as a tool for building abstractions
// * start with the contract when adding a new type/function
// ** document the contract before you implement it
// ** make the contract inform the implementation, not the other way around
// ** there's no such thing as self-documenting code
// ** I'm a big fan of the old golint rule:
//    every exported entity must be documented.
// * Use tests to help inform abstractions
// * Application-scoped vs request-scoped information
// ** Request scope can be a single HTTP request, a single invocation of a CLI,
//    or one "entry" into a library.
// ** Use scope of information to inform abstraction design.
//    Things that change rarely, vs things that change often.
// ** Accepted interfaces should be equest scoped
// ** Tip: Argument order based on scope
// *** Exception: context
// * maybe: sometimes code repetition is okay
// ** DRY vs DAMP; tests

// TODO: "shared arguments"
// TODO: tie ideas here back into the guidance from prior section.
--

// TODO: "shallow modules" "lots of top level function"
include::fix-long-funcs.adoc[]

// = Tangent: Libraries
//
// Maybe
//
// [.notes]
// --
// * be deliberate about features
// ** You can't just "add" a feature. Cross-product.
// --
// = Fixing legacy code
// TODO: Picture of David Winterbottom's tweet
// https://codeinthehole.com/
// [.notes]
// --
// * pay your debts in installments
// ** don't try to rewrite legacy code from scratch
// ** don't be afraid of changing things
// ** leave it better than you found it
// * Testing is a design problem
// ** Maybe: Use pattern from before to abstract away
//    global dependencies
// --
