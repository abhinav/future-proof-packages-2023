= Really long functions

[%step]
[pikchr, height=500px]
....
boxwid = 1in
movewid = 0.5in
right

P: box ht 2in
move
Q: box same

down
A: box same ht 0.5in with nw at (Q.e.x+movewid, Q.n.y+0.2in)
move 0.1in
B: box same ht 0.3in
move 0.1in
C: box same ht 0.6in
move 0.1in
D: box same ht 0.2in
move 0.1in
E: box same ht 0.4in

assert (A.n.y-E.s.y == Q.ht + 0.4in)

markPos = 0
define markAt {
  markPos += $2
  line from ($1.nw.x, $1.nw.y-markPos) right until even with $1.e
}

markAt(Q, A.ht)
markAt(Q, B.ht)
markAt(Q, C.ht)
markAt(Q, D.ht)

arrow from 0.1in east of P.e to 0.1 west of Q.w
arrow from 0.1in east of Q.e right until even with 0.1 west of A.w
....

[.notes]
--
Let me share an example.

Okay, so if we have a really long function,
the obvious starting advice is: (*step*)
find the N concrete things it does,
and then split it into separate functions.

I'm here to suggest that don't *just* do that -- don't stop there.
There's usually some shared information between these functions;
that's why they were all part of one big function.
--

[.columns]
== Really long functions

[.column]
--
[pikchr, height=500px]
....
boxwid = 1in

down
A: box ht 0.5in
move 0.1in
B: box ht 0.3in
move 0.1in
C: box ht 0.6in
move 0.1in
D: box ht 0.2in
move 0.1in
E: box ht 0.4in

box wid 0.1in ht D.ht with nw at A.nw
box same with nw at B.nw
box same with nw at C.nw
box same with nw at D.nw
box same with nw at E.nw


linerad = 0.1in
arrow from A.e right 0.3in then down until even with B then to B.e
arrow from A.e right 0.15in then down until even with 0.1in north of C then left until even with C.e
arrow from 0.1 south of C.e right 0.3in then down until even with E then to E.e
arrow from 0.1 south of C.e right 0.15in then down until even with D then to D.e
....
--

[.column%step]
--
[pikchr, height=500px]
....
boxwid = 0.9in

down
A: box ht 0.5in
move 0.1in
B: box ht 0.3in
move 0.1in
C: box ht 0.6in
move 0.1in
D: box ht 0.2in
move 0.1in
E: box ht 0.4in

S: box wid 0.1in ht D.ht with e at 0.5in west of A.w

linerad = 0.1in
arrow <-> from S to A chop
arrow from S right 0.35in then down until even with B then right to B chop
arrow from S right 0.35in then down until even with E then right to E chop

arrow from A.e right 0.15in then down until even with 0.1in north of C then left until even with C.e
arrow from 0.1 south of C.e right 0.15in then down until even with D then to D.e
....
--

[.notes]
--
You might find that
some parameters are repeated between these functions,
or that flow jumps between them.

This is a good place to find an abstraction
for the functionality implemented by the large function.
(*step*)

For example,

* A shared object could be defined here tracking the parameters
  that are duplicated across functions
* Each "stage" of the larger function becomes a method on the object.
* Information is shared between functions via parameters,
  but they may also feed information back to the larger abstraction's scope.

// TODO:
// * Move parameters with "big scope" into struct fields
// * If multiple functions feed back information, use a struct field again

// TODO
// If you have a really long function, this direction is a good place
// for you to start decomposing the responsibilities of the function
// into meaningful subcomponents.
// This makes for a better first step to "find the abstraction" in there
// than just converting it into multiple functions.
//
// It also has a very nice benefit of allowing injection of any global dependency
// so that you can more easily test that really long function.
--
