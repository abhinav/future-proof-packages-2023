= Finding and fixing problems

[.notes]
--
Finding and fixing problems.

First, just to recap,
I said earlier that packages aren't future-proof
if changing them causes disruptions,
and I claimed that that's a symptom of a design that leaks complexity.

So how do we go about fixing these leaks?
I will talk about this at two levels:

* First, low-level closer to the code.
  Patterns you should keep an eye out for
  that *probably* leak complexity.
* After that, I'll zoom out and talk about design at a higher level.

As I get into the first section,
please be aware that I'll be making generalizations.
The way to interpret this is
"code that looks like this tends to leak complexity".

// TODO: probably don't need to hedge here.

Okay, let's get into it.

// TODO:
//
// Maybe:
//
// * Unstoppable goroutines
// ** Add a means of stopping them -- context or otherwise
// ** Never spawn in `init()`
// * Naming: names and scopes
// ** Inconsistency in naming
// ** Stuttering
// ** Document public API of internal types with exported names
// ** Consistency above all else
// * Errors: structured and sentinel
// * Bidirectional channels at boundaries / channels are rare
--

= Over-reliance on primitives

[.notes]
--
Something that makes it easy to leak complexity is
an over-reliance on primitive types in your core logic.

strings, bools, and ints are available everywhere -- they're so easy to use --
so I use them everywhere because defining a type "adds complexity" to my code.
As a result of that, I end up leaking that complexity outside.

I think this is better demonstrated with an example.
--

include::fix-string.adoc[]
include::fix-map.adoc[]
include::fix-serialized-types.adoc[]
include::fix-bool.adoc[]
include::fix-callback.adoc[]
// TODO: maybe: closures vs objects
// ** You can implement a class a closure doesn't mean you should.
// ** Isolate concepts, give them names, add interfaces (middleware example)
// *** Closure want to be objects when they grow up
include::fix-premature-iface.adoc[]
include::fix-big-iface.adoc[]
include::fix-global.adoc[]

= Zooming out

[.notes]
--
So I've been talking about very specific code samples.
As promised, I'm going to zoom out now.
Now I want to talk about an application holistically.
--

include::concept-flow.adoc[]
include::concept-scope.adoc[]
include::concept-area-depth.adoc[]

== !

[.notes]
--
Unfortunately, I don't have a list of rules that we can follow
to always get the right abstraction.
But I have some tools that'll help you find it.

// Finding the abstraction
// * really long functions (maybe?)
// * look for conditionals
// * currying as a tool for building abstractions
// ** shared arguments => object
// * start by documenting the contract when adding a new type/function
// ** make the contract inform the implementation, not the other way around
// ** there's no such thing as self-documenting code
// ** I'm a big fan of the old golint rule:
//    every exported entity must be documented.
// * Use tests to help inform abstractions
// * Application-scoped vs request-scoped information
// ** Request scope can be a single HTTP request, a single invocation of a CLI,
//    or one "entry" into a library.
// ** Use scope of information to inform abstraction design.
//    Things that change rarely, vs things that change often.
// ** Accepted interfaces should be request scoped
// ** Tip: Argument order based on scope
--

// TODO: this is "finding an abstraction"
include::fix-long-funcs.adoc[]

// = Tangent: Libraries
//
// Maybe
//
// [.notes]
// --
// * be deliberate about features
// ** You can't just "add" a feature. Cross-product.
// --
// = Fixing legacy code
// TODO: Picture of David Winterbottom's tweet
// https://codeinthehole.com/
// [.notes]
// --
// * pay your debts in installments
// ** don't try to rewrite legacy code from scratch
// ** don't be afraid of changing things
// ** leave it better than you found it
// * Testing is a design problem
// ** Maybe: Use pattern from before to abstract away
//    global dependencies
// --
