= Maps at boundaries

[.notes]
--
TODO: this is just an extension of over-reliance on primitives

TODO: `map[string][]string` tells me basically nothing.

Maps accepted or returned at package boundaries
are very often a leaking implementation detail.

Do we actually need to accept/return a map there
or is that just how it's implemented internally
so it's easy to re-use?

I'll talk about a couple cases where you might leak maps:

A function accepting, say, a `map[string]T` // TODO
because that's how we store it internally.
Does `T` have a name field that you're keying on?
Why not accept a `[]T` and build the map internally?
TODO: explain, examples

An interesting one that I've run into is enforcing uniqueness on name
when that's actually not a requirement. (TODO health waitset example.)
A technique we could've employed here is using handles:
NewGate returns an object that represents the gate,
and that's enough to refer to it and do things with it in the future.
TODO better explain
Depending on the needs,
the handle implementation can hold its own state,
or a pointer to the parent object and an index into a slice in the parent
with relevant state.

Lastly, on the other side, returning maps when it's an implementation detail.
If the uniqueness isn't a hard requirement now and forever,
and just how we're representing information for ease, don't return the map.

Also, if you do, be careful about accepting or returning a map
at boundaries where the caller may then mutate the map.
TODO
--
