= Finding and fixing problems

[.notes]
--
Finding and fixing problems.

First, just to recap,
I said earlier that packages aren't future-proof
if changing them causes disruptions,
and I claimed that that's a symptom of a design that leaks complexity.

So how do we go about fixing these leaks?
I will talk about this at two levels:

* First, low-level closer to the code.
  Patterns you should keep an eye out for
  that *probably* leak complexity.
* After that, I'll zoom out and talk about design at a higher level.

As I get into the first section,
please be aware that I'll be making generalizations.
The way to interpret this is
"code that looks like this tends to leak complexity".

// TODO: probably don't need to hedge here.

Okay, let's get into it.

// TODO Maybe:
//
// * Unstoppable goroutines
// ** Add a means of stopping them -- context or otherwise
// ** Never spawn in `init()`
// * Errors: structured and sentinel
// * Bidirectional channels at boundaries / channels are rare
--

= Over-reliance on primitives

[.notes]
--
Something that makes it easy to leak complexity is
an over-reliance on primitive types in your core logic.

strings, bools, and ints are available everywhere -- they're so easy to use --
so I use them everywhere because defining a type "adds complexity" to my code.
As a result of that, I end up leaking that complexity outside.

I think this is better demonstrated with an example.
--

include::fix-string.adoc[]
include::fix-map.adoc[]
include::fix-serialized-types.adoc[]
include::fix-bool.adoc[]
include::fix-callback.adoc[]
// TODO: maybe: closures vs objects
// ** You can implement a class a closure doesn't mean you should.
// ** Isolate concepts, give them names, add interfaces (middleware example)
// *** Closure want to be objects when they grow up
include::fix-premature-iface.adoc[]
include::fix-big-iface.adoc[]
include::fix-global.adoc[]

= Zooming out

[.notes]
--
So I've been talking about very specific code samples.
As promised, I'm going to zoom out now.
Now I want to talk about an application holistically.
--

include::concept-flow.adoc[]
include::concept-scope.adoc[]
include::concept-area-depth.adoc[]

= Finding the abstraction

[.notes]
--
Okay, so I've mentioned this a couple times.
The idea of finding the right abstraction to hide complexity.

The concepts I just brought up:
flow of information, scope, surface area, and depth.
You can use those to help you find the abstraction.
--

// TODO: curry might be a better follow to long funcs

include::fix-long-funcs.adoc[]
include::fix-conds.adoc[]
include::fix-curry.adoc[]

= Writing the abstraction

[.notes]
--
Some tips for writing the abstraction once you've found it.
--

== Start on the outside

* Don't implement right away
* Decide the contract first

[.notes]
--
Start on the outside:

* Don't jump into the implementation right away.
* Figure out the purpose of the abstraction,
  and its contract before you start implementing it.
** By contract, I mean, what's the input, what's the output --
   where do the responsibilities of this object start versus end.
--

== Plan for expansion

include::expansion-table.adoc[]

[.notes]
--
Use the tools we discussed earlier
to plan for expansion of the abstraction, its inputs, and outputs.
--

== Name things clearly

* Don't be redundant
* Don't build a kitchen sink
** No 'helper' or 'util'
* Consistency over all else

[.notes]
--
TODO

* Kitchen sink
** 'helper' is uninformative
** 'util' will always be wide and shallow
* Consistency
** New terms have to be incorporated by a reader
   into their mental model of an abstraction.
** Re-use similar names for similar concepts.
** If you have something called UserDetails already,
   don't introduce PostData. Call it PostDetails.
--

== Document it

* Write down the contract
* No self-documenting code
* Document all exported objects
+
[%step]
[source,yaml]
----
# .golangci.yml

issues:
  # Re-enable requiring all exported entities
  # to be documented.
  exclude-use-default: false
----

[.notes]
--
* Document it. Many people miss this part.
* There's no such thing as self-documenting code.
* I'm personally a big fan of the old golint rule
  that requires all exported things must be documented.
  I still enable it in my code.
** Revive has it enabled by default.
** golangci-lint disables that check by default,
   but you can enable it with this snippet (*step*),
   although it drops a few other default exclusions too.
   Personally, I haven't found that to be a problem.
--

[.columns]
== Make the implementation match the contract

[.column.is-one-third]
--
--

[.column.is-two-thirds.text-left]
--
üëé "This is what it does" +
üëç "This is what it's supposed to do"
--

[.notes]
--
I may be repeating myself here,
but it's important that the contract inform the implementation,
not the other way around.
--

== Don't leak the implementation

* Insulate internals from the outside world
* Avoid primitive obsession
* Define domain objects

// TODO: diagram

[.notes]
--
--

== Don't backtrack the flow of information

Information fed once should not be fed again

// TODO: diagram

[.notes]
--
--

== Don't add features, incorporate

* Features do not exist in isolation
* Adjust the mental model
+
[source,go]
----
type SiteGen struct{ AddSlash bool }
/* versus */
type SiteGen struct{ LinkStyle LinkStyle }
----
* It's okay to say No

[.notes]
--
Don't just 'add' a feature.
Features don't exist in isolation.
Consider how the feature interacts with other features.

See how it fits into your mental model of the abstraction.
Can you adjust the mental model to account for it?
Think back to the site generator example.
An "AddSlash" boolean does not fit there for me,
but an object responsible for styling links does.

If it breaks the model, if you can't incorporate it,
it's okay to say no.
--
